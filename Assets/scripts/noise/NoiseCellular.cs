using UnityEngine;

public class NoiseCellular : Noise
{
	static readonly float[,] LUT_Cellular2D =
	{
		{ 0.250708038153379f, 0.249427694225972f }, { 0.0869437515459609f, 0.184749552136559f }, { -0.0413046810386655f, 0.403981043609444f }, { -0.0293907403944378f, 0.49913076795134f }, { -0.315196544673176f, 0.112131089257973f }, { 0.284986509052738f, -0.239847923263601f }, { -0.0546095496331694f, -0.387046123842226f }, { -0.455916077222658f, -0.0285751529349881f },
		{ -0.159697602772812f, -0.069715028041617f }, { -0.13499310031726f, -0.24544360590384f }, { 0.0712784658236382f, -0.210509752150429f }, { -0.183139799640577f, 0.0989616462898892f }, { -0.120954871197088f, -0.404416525393099f }, { 0.0397020774694894f, -0.332051780499794f }, { 0.156583517215517f, -0.355997670354414f }, { -0.118253736644093f, -0.273834274561332f },
		{ 0.407280633332697f, 0.0695704319921797f }, { -0.181395165743625f, -0.0360988318776937f }, { 0.149517494831831f, 0.275252778735439f }, { -0.239680212428189f, -0.296006529252734f }, { 0.0648980428870777f, -0.165592673711567f }, { -0.164235060392619f, -0.044152747040758f }, { -0.0880929686013205f, 0.319070946524584f }, { -0.359118900783392f, -0.145231031891457f },
		{ 0.13904415334069f, 0.115456824951353f }, { 0.0842991474059002f, 0.0604465759876108f }, { -0.353890154574729f, 0.0563377224444608f }, { -0.191548757651777f, 0.458666569079093f }, { -0.0305852649733824f, -0.103294981589093f }, { -0.244249558051389f, -0.184215340423203f }, { -0.335508375435451f, 0.366044689290556f }, { -0.0842977163909816f, -0.181691541539155f },
		{ -0.194574831896163f, -0.0360977050226033f }, { -0.0136275832633322f, 0.348855027149362f }, { 0.112779750419581f, 0.250740618802603f }, { 0.446016898314568f, 0.19375271707891f }, { 0.370298098312872f, -0.308060032847868f }, { -0.174031950246891f, 0.068370776312583f }, { -0.0320673407373619f, -0.490638717459424f }, { 0.277163688315855f, 0.12127656301314f },
		{ 0.0568558134728565f, 0.350239706769654f }, { 0.205869692362488f, -0.400914200219679f }, { -0.391075780729104f, 0.239049951016082f }, { 0.0898368903641186f, 0.396970664249824f }, { -0.12708545544806f, 0.205550073947438f }, { 0.329713608183662f, -0.00124387983313534f }, { 0.215101309878185f, 0.31230482220907f }, { -0.299990667492553f, 0.0362774842315264f },
		{ -0.162024884165002f, 0.390269354299181f }, { 0.247175458660869f, -0.164649461140494f }, { -0.00702116345848802f, 0.177588576697459f }, { -0.0535304504389743f, -0.40845998572649f }, { 0.0145856109573733f, 0.382905331923157f }, { 0.216280639152196f, -0.209660172189405f }, { 0.402533050670213f, 0.162391078948541f }, { -0.365399410561553f, -0.110910594428755f },
		{ 0.174770668216721f, -0.397793366833591f }, { 0.32230859429012f, -0.137029006198646f }, { 0.171029762566206f, -0.381445776782064f }, { -0.229611775033244f, 0.0104655318145362f }, { -0.293902727481095f, -0.373532221230389f }, { 0.285221677418125f, -0.296232913639187f }, { -0.28269015083746f, 0.403270257987613f }, { -0.43086572953841f, -0.179317972362171f },
		{ -0.310057947802406f, -0.0787640260872092f }, { 0.0533765298216697f, 0.440202724974886f }, { -0.354033675325863f, 0.0698196861581185f }, { 0.311115679250857f, -0.129663260096312f }, { 0.229255390402563f, -0.328758027086313f }, { -0.33536302092319f, -0.290805878133609f }, { -0.384663256926429f, 0.238445759121866f }, { 0.281520545158111f, 0.264852699142123f },
		{ -0.218357566260313f, 0.0793706065412086f }, { 0.164980332762834f, 0.182041388247544f }, { 0.307207781894971f, -0.22816860870366f }, { -0.454503892591875f, 0.0592878003115745f }, { -0.0894050246174167f, -0.418329169674f }, { -0.276089185505125f, 0.0439845273659423f }, { -0.151684626764266f, -0.0037583472744015f }, { 0.133104875185567f, 0.185590164995452f },
		{ -0.102966431104062f, -0.433484981926515f }, { 0.131172549940418f, 0.278916720062804f }, { 0.0938441203621891f, 0.378164201175125f }, { 0.390368899361443f, 0.0258977574673016f }, { -0.304185462809122f, -0.220404718569479f }, { 0.041114945526263f, 0.0231437900813286f }, { -0.0553679533766611f, 0.109770312957138f }, { -0.153408636511854f, -0.259551360860073f },
		{ 0.18314747642386f, 0.346041366704221f }, { -0.202409229916045f, 0.0830509156789105f }, { 0.00263870789986387f, -0.14989084637648f }, { -0.0174869839365028f, -0.0973506129991467f }, { -0.335359236494802f, -0.0804404327143762f }, { -0.241126779112638f, -0.0757387480664328f }, { 0.261018611568062f, -0.0492869133053188f }, { -0.0959999647631716f, 0.222694380942215f },
		{ 0.299431284684768f, 0.106521457979214f }, { 0.227637867405222f, -0.174455746888093f }, { 0.0922702482664376f, 0.26819649456602f }, { -0.151399312307839f, -0.125974097818691f }, { 0.108938078293079f, -0.304856700693976f }, { -0.438854244630266f, -0.132330505223942f }, { 0.0717952564882181f, 0.275888210440627f }, { -0.215751231440234f, 0.0355311465640098f },
		{ 0.422176755226945f, -0.0189335471371869f }, { -0.408859832848213f, 0.000537910856484469f }, { -0.0362598525704807f, 0.357413669332284f }, { -0.28032466328989f, 0.347911002432735f }, { 0.198710871738271f, 0.0601322001820659f }, { 0.285019264549449f, -0.298882702144618f }, { -0.0780288055851716f, 0.441572196343895f }, { 0.15900180964612f, 0.449105031972222f },
		{ 0.203387295255816f, 0.0755020611275794f }, { 0.466447410709773f, 0.0154577407226987f }, { 0.09642323208626f, 0.448221598304089f }, { -0.147868203532494f, -0.0586292019305197f }, { 0.32832047650105f, -0.0852312055816367f }, { -0.229855755874368f, -0.229760903875133f }, { 0.133073203870081f, 0.474537707771751f }, { 0.158309714495696f, 0.366021857483007f },
		{ 0.132325770252795f, 0.239780173970358f }, { 0.0390928599864625f, -0.244597408317102f }, { 0.0343482304430441f, 0.232382438149273f }, { 0.15455940326916f, -0.237057253070687f }, { -0.176575322299199f, 0.422823548490547f }, { 0.209170093404748f, -0.385858241380788f }, { 0.020364957428845f, 0.386396490846172f }, { 0.0812228894854148f, 0.189603055294904f },
	};

	static readonly float[,] LUT_Cellular3D =
	{
		{ -0.0754560603505074f, -0.352466298044147f, 0.235267278808342f }, { 0.375595337603153f, 0.231008132619556f, 0.0676738115920836f }, { -0.117712754267955f, 0.118823977675711f, 0.383220995235334f }, { -0.315022593984555f, -0.356826861858672f, 0.14429057112708f }, { 0.278226241297412f, -0.0824907503739393f, 0.0319716918006141f }, { 0.0721684409910568f, -0.0568065516303533f, -0.270396222381411f }, { -0.188642405575107f, 0.426286802128244f, -0.0997959961417977f }, { -0.21241450198315f, -0.156988971972095f, -0.371816039814609f },
		{ 0.0863582411916157f, 0.247123671654167f, -0.178732678014738f }, { -0.316057297392795f, -0.166683643723161f, -0.0611778223515034f }, { 0.328289724658807f, -0.247873201332817f, 0.0327134144703831f }, { 0.298161327325315f, 0.157043311120146f, -0.194787277619172f }, { 0.235578213651412f, -0.435245262589905f, -0.0422642484955862f }, { 0.327685758031643f, 0.241172355667957f, -0.207969548732154f }, { 0.00871052597199329f, 0.443412172727963f, -0.223881734853918f }, { -0.327815963122739f, -0.0632251381117975f, 0.0638698032894591f },
		{ 0.171293757904134f, -0.268967805310664f, 0.247330179961144f }, { -0.0949972350817184f, 0.063004943044643f, 0.294697968547845f }, { -0.0300170884515747f, -0.246318276945069f, -0.352747202100628f }, { -0.311656463135497f, 0.251926029121401f, -0.0149343564869993f }, { 0.0967990124710062f, -0.0232670198658895f, 0.411444409421758f }, { 0.171471713858107f, 0.34757034412655f, 0.308498108582644f }, { -0.226321846928427f, 0.0150474907816183f, -0.28139906987385f }, { 0.31642670441849f, -0.213204067384848f, -0.134793324142343f },
		{ -0.153080406416659f, -0.0708935401097545f, -0.374335538114601f }, { -0.141898142497496f, 0.396109169772019f, 0.217791125319443f }, { 0.0705297169419404f, -0.129260274971251f, 0.406859211329066f }, { 0.251810227220121f, 0.124949974348436f, -0.393553355584399f }, { -0.0368495944166345f, 0.241600973547733f, 0.148996628567347f }, { 0.386176272686462f, 0.0704541941317958f, 0.282892824561693f }, { -0.448707875225182f, -0.211852236277489f, -0.0593266252597142f }, { 0.26362413360482f, 0.121776945503026f, 0.400589609531262f },
		{ 0.0356172105184771f, -0.0694961844311607f, 0.207096739368625f }, { 0.0220676410856254f, -0.243509045746833f, -0.346155427302331f }, { -0.332850454243997f, -0.273747394478838f, -0.22048981878446f }, { -0.0192534015774575f, 0.274761909811407f, 0.0538736339590546f }, { 0.165317580671615f, -0.17816927829344f, 0.111506805650966f }, { 0.160011063093249f, -0.189988000083815f, -0.123927439752988f }, { -0.0556742716525043f, -0.145924001539992f, 0.255437545994726f }, { -0.0756379835094876f, 0.117828081134182f, -0.0120650913993298f },
		{ -0.197210049133133f, 0.366845948861914f, -0.069149027078396f }, { -0.327754728775996f, -0.150084029241845f, 0.145075072942995f }, { 0.161237889571005f, -0.243941829192892f, -0.175439034288131f }, { -0.309384192990048f, 0.073277812505501f, 0.11883287100647f }, { 0.0232216051376899f, -0.108987914593452f, 0.0761115614757536f }, { -0.347002244980896f, -0.0790758856307948f, -0.292676467340568f }, { 0.103534060321088f, -0.203205137065946f, 0.118248046232412f }, { -0.179220531222376f, -0.344376091077383f, 0.264564404302929f },
		{ -0.105623452834155f, 0.172260765651461f, 0.286525292886974f }, { 0.274615478686034f, 0.39708151176951f, 0.108857497420682f }, { 0.0272308304879481f, -0.29857786875525f, 0.218901052935987f }, { 0.181150683549163f, -0.0390599930595309f, 0.0949206494787788f }, { -0.00544027941931291f, 0.258695402688113f, 0.159206235697394f }, { 0.14666780165587f, -0.295910619616463f, -0.141165960124873f }, { -0.426587975388305f, 0.0760382887605349f, 0.0472664490532966f }, { -0.0152659279961116f, 0.180812473889749f, 0.259829082596259f },
		{ 0.352340969489831f, 0.0949483549802f, -0.177789296750313f }, { -0.0905631767650262f, 0.263643399485011f, -0.177426671881535f }, { -0.0970863948176078f, -0.33023504648773f, -0.285310888372764f }, { 0.0979689417894761f, 0.1887091910561f, 0.433033843855928f }, { -0.326971547677627f, -0.249788070497878f, -0.234005939695248f }, { -0.325347232785791f, -0.316738721236934f, -0.20152323790929f }, { 0.218137901142078f, 0.339775203104837f, 0.136861866669955f }, { 0.00486092295852336f, 0.152424623596169f, -0.207909928163038f },
		{ -0.0224237596869308f, -0.111900496204799f, -0.418651994989208f }, { -0.320527275160396f, 0.0837356323613371f, -0.0780152086437003f }, { 0.0280545571637402f, 0.407068362508662f, -0.232043213598857f }, { 0.173273195782102f, 0.032319521677456f, 0.251161338290762f }, { -0.127089097779856f, -0.130136356191262f, 0.298162430252907f }, { 0.428700245699538f, 0.0346044966001166f, -0.0204478035247239f }, { 0.123276076546935f, -0.176201654967961f, 0.140866137138884f }, { -0.167754642481773f, -0.16902730786879f, 0.199609554336224f },
		{ 0.223309910629808f, -0.0669686697938046f, -0.130671553077962f }, { -0.287382586145988f, -0.29283231663167f, 0.113706916565294f }, { 0.261284336575583f, -0.0802855040763278f, 0.324631782222548f }, { 0.129138154866895f, -0.180303542151919f, -0.0542081960881317f }, { -0.00322524201704166f, -0.243319454466774f, -0.362203650983436f }, { -0.268885359697498f, -0.313746527308031f, -0.0862470339408644f }, { 0.268103596101711f, -0.0377728764616946f, 0.00828001824924351f }, { 0.201924589190448f, 0.252778778826486f, 0.169097036415934f },
		{ 0.0546812195057308f, 0.0800291713727608f, 0.0127197209798533f }, { -0.329478417276474f, -0.252260304381621f, 0.0811441199641992f }, { 0.0091774761997484f, -0.28113417626388f, 0.237416782049565f }, { 0.0116337713075201f, -0.0188369389512223f, 0.480322379472401f }, { -0.305467029064262f, 0.341714339313991f, 0.173830325450309f }, { 0.000413372001765056f, 0.11516372089457f, -0.0474483021807772f }, { 0.00146930779539023f, 0.174098694109033f, 0.187423873199821f }, { -0.101880886099702f, -0.158549810567217f, -0.455340710792498f },
		{ -0.0195640688989295f, 0.0308029895294849f, -0.00872802775024206f }, { -0.063948607587152f, -0.171039592434666f, -0.0894551497004384f }, { -0.0545760624153979f, 0.464803465232108f, 0.124693473073799f }, { 0.3502937004872f, -0.199728724661434f, -0.141569473253716f }, { 0.0480124973209703f, 0.0425320941310352f, 0.0576268391267263f }, { 0.0700554646300197f, -0.120177701533213f, 0.362939649754906f }, { -0.0888968497938477f, -0.0442641180954902f, 0.166977335738641f }, { 0.0697174979695231f, 0.0644477521727814f, -0.172231794817971f },
		{ 0.222483000892674f, 0.194106396048384f, 0.316456746402756f }, { -0.170135444019886f, -0.00324314723026486f, -0.165167042724334f }, { 0.188254592483392f, -0.127943637635902f, 0.289532792150166f }, { 0.0321017602916118f, 0.348205815674701f, -0.0423729539991641f }, { 0.0507248787487231f, -0.253204804600527f, -0.0490837360518831f }, { 0.111313377002407f, 0.349362368224835f, 0.334910365753693f }, { 0.257937106004627f, 0.105411965585877f, -0.361711729374542f }, { 0.0512900731488198f, -0.229549656856243f, 0.257417925577553f },
		{ -0.0381335012121889f, -0.330155168592936f, -0.333446175022896f }, { 0.110047540932941f, 0.43508905862244f, 0.0277996810151547f }, { 0.363155663971144f, 0.0668365347413614f, -0.229422247703535f }, { 0.30237496486279f, 0.181161839632804f, -0.221745064022372f }, { -0.175531221684405f, 0.118314189158817f, -0.0946833041061461f }, { -0.0470680223650999f, 0.0792855222829776f, 0.300601076715962f }, { 0.467711149632443f, -0.0521985142563184f, -0.00732893624357533f }, { -0.486423326745718f, 0.110947174674555f, 0.0263696605073731f },
		{ 0.0673719962838721f, -0.0778641524623683f, -0.467765990824302f }, { -0.165167932030356f, 0.0892720815465723f, -0.453272099337044f }, { 0.333578699113336f, -0.0297017005530308f, -0.0593905771419292f }, { 0.293288259258728f, 0.329403857510877f, -0.0759052841271396f }, { -0.204973281426423f, -0.309881996850931f, -0.150366438202898f }, { -0.206856274245894f, -0.179009067617496f, 0.221566961074757f }, { 0.255178679781575f, 0.153287028194758f, 0.00198543730535206f }, { -0.0636156864091478f, -0.0803024091741419f, 0.0530485248550313f },
		{ 0.0751579446945424f, 0.182907776192345f, 0.18834028318176f }, { -0.468324198184296f, -0.115280697354904f, 0.0483896328016261f }, { 0.0345510640405808f, 0.386355307366794f, 0.151812147023893f }, { 0.365574769745067f, -0.00837337833290497f, -0.18850992962134f }, { -0.0806692553709122f, 0.0415279784091643f, 0.17127732820122f }, { -0.118467082405899f, -0.0597561635624523f, 0.317959096715079f }, { -0.076768269845923f, -0.0144695926151897f, -0.15893078666523f }, { -0.248815876390639f, -0.387878624851675f, -0.0522421374813546f },
	};

	static readonly float[,] LUT_Cellular2D_HQ =
	{
		{ 0.501416076306759f, 0.498855388451945f }, { 0.173887503091922f, 0.369499104273119f }, { -0.0826093620773309f, 0.807962087218888f }, { -0.0587814807888756f, 0.998261535902679f }, { -0.630393089346351f, 0.224262178515945f }, { 0.569973018105476f, -0.479695846527202f }, { -0.109219099266339f, -0.774092247684452f }, { -0.911832154445317f, -0.0571503058699763f },
		{ -0.319395205545624f, -0.139430056083234f }, { -0.26998620063452f, -0.490887211807679f }, { 0.142556931647276f, -0.421019504300857f }, { -0.366279599281153f, 0.197923292579778f }, { -0.241909742394175f, -0.808833050786198f }, { 0.0794041549389788f, -0.664103560999588f }, { 0.313167034431034f, -0.711995340708829f }, { -0.236507473288186f, -0.547668549122665f },
		{ 0.814561266665395f, 0.139140863984359f }, { -0.362790331487249f, -0.0721976637553874f }, { 0.299034989663662f, 0.550505557470879f }, { -0.479360424856379f, -0.592013058505467f }, { 0.129796085774155f, -0.331185347423135f }, { -0.328470120785237f, -0.088305494081516f }, { -0.176185937202641f, 0.638141893049167f }, { -0.718237801566785f, -0.290462063782915f },
		{ 0.278088306681379f, 0.230913649902705f }, { 0.1685982948118f, 0.120893151975222f }, { -0.707780309149458f, 0.112675444888922f }, { -0.383097515303555f, 0.917333138158185f }, { -0.0611705299467649f, -0.206589963178185f }, { -0.488499116102778f, -0.368430680846406f }, { -0.671016750870902f, 0.732089378581113f }, { -0.168595432781963f, -0.36338308307831f },
		{ -0.389149663792326f, -0.0721954100452067f }, { -0.0272551665266645f, 0.697710054298724f }, { 0.225559500839161f, 0.501481237605205f }, { 0.892033796629135f, 0.38750543415782f }, { 0.740596196625744f, -0.616120065695737f }, { -0.348063900493782f, 0.136741552625166f }, { -0.0641346814747239f, -0.981277434918847f }, { 0.55432737663171f, 0.242553126026281f },
		{ 0.113711626945713f, 0.700479413539308f }, { 0.411739384724977f, -0.801828400439358f }, { -0.782151561458208f, 0.478099902032164f }, { 0.179673780728237f, 0.793941328499648f }, { -0.25417091089612f, 0.411100147894876f }, { 0.659427216367324f, -0.00248775966627068f }, { 0.43020261975637f, 0.624609644418139f }, { -0.599981334985107f, 0.0725549684630529f },
		{ -0.324049768330005f, 0.780538708598361f }, { 0.494350917321738f, -0.329298922280988f }, { -0.014042326916976f, 0.355177153394918f }, { -0.107060900877949f, -0.81691997145298f }, { 0.0291712219147466f, 0.765810663846315f }, { 0.432561278304393f, -0.41932034437881f }, { 0.805066101340427f, 0.324782157897081f }, { -0.730798821123107f, -0.22182118885751f },
		{ 0.349541336433442f, -0.795586733667181f }, { 0.64461718858024f, -0.274058012397292f }, { 0.342059525132412f, -0.762891553564127f }, { -0.459223550066487f, 0.0209310636290725f }, { -0.58780545496219f, -0.747064442460778f }, { 0.570443354836249f, -0.592465827278374f }, { -0.56538030167492f, 0.806540515975226f }, { -0.861731459076821f, -0.358635944724342f },
		{ -0.620115895604812f, -0.157528052174418f }, { 0.106753059643339f, 0.880405449949772f }, { -0.708067350651726f, 0.139639372316237f }, { 0.622231358501715f, -0.259326520192625f }, { 0.458510780805126f, -0.657516054172625f }, { -0.67072604184638f, -0.581611756267217f }, { -0.769326513852858f, 0.476891518243733f }, { 0.563041090316222f, 0.529705398284246f },
		{ -0.436715132520625f, 0.158741213082417f }, { 0.329960665525668f, 0.364082776495089f }, { 0.614415563789942f, -0.45633721740732f }, { -0.909007785183749f, 0.118575600623149f }, { -0.178810049234833f, -0.836658339348f }, { -0.55217837101025f, 0.0879690547318845f }, { -0.303369253528533f, -0.00751669454880299f }, { 0.266209750371134f, 0.371180329990904f },
		{ -0.205932862208124f, -0.866969963853029f }, { 0.262345099880836f, 0.557833440125609f }, { 0.187688240724378f, 0.75632840235025f }, { 0.780737798722887f, 0.0517955149346032f }, { -0.608370925618243f, -0.440809437138958f }, { 0.0822298910525261f, 0.0462875801626572f }, { -0.110735906753322f, 0.219540625914276f }, { -0.306817273023707f, -0.519102721720146f },
		{ 0.366294952847719f, 0.692082733408441f }, { -0.40481845983209f, 0.166101831357821f }, { 0.00527741579972774f, -0.299781692752959f }, { -0.0349739678730057f, -0.194701225998293f }, { -0.670718472989604f, -0.160880865428752f }, { -0.482253558225276f, -0.151477496132866f }, { 0.522037223136125f, -0.0985738266106375f }, { -0.191999929526343f, 0.445388761884429f },
		{ 0.598862569369537f, 0.213042915958428f }, { 0.455275734810445f, -0.348911493776186f }, { 0.184540496532875f, 0.536392989132039f }, { -0.302798624615678f, -0.251948195637381f }, { 0.217876156586158f, -0.609713401387953f }, { -0.877708489260532f, -0.264661010447884f }, { 0.143590512976436f, 0.551776420881253f }, { -0.431502462880468f, 0.0710622931280196f },
		{ 0.84435351045389f, -0.0378670942743737f }, { -0.817719665696427f, 0.00107582171296894f }, { -0.0725197051409614f, 0.714827338664568f }, { -0.56064932657978f, 0.695822004865471f }, { 0.397421743476542f, 0.120264400364132f }, { 0.570038529098898f, -0.597765404289235f }, { -0.156057611170343f, 0.88314439268779f }, { 0.31800361929224f, 0.898210063944443f },
		{ 0.406774590511633f, 0.151004122255159f }, { 0.932894821419546f, 0.0309154814453974f }, { 0.19284646417252f, 0.896443196608179f }, { -0.295736407064989f, -0.117258403861039f }, { 0.6566409530021f, -0.170462411163273f }, { -0.459711511748736f, -0.459521807750266f }, { 0.266146407740162f, 0.949075415543502f }, { 0.316619428991393f, 0.732043714966014f },
		{ 0.26465154050559f, 0.479560347940717f }, { 0.078185719972925f, -0.489194816634204f }, { 0.0686964608860883f, 0.464764876298545f }, { 0.309118806538319f, -0.474114506141374f }, { -0.353150644598397f, 0.845647096981094f }, { 0.418340186809496f, -0.771716482761576f }, { 0.0407299148576901f, 0.772792981692343f }, { 0.16244577897083f, 0.379206110589807f },
	};

	static readonly float[,] LUT_Cellular3D_HQ =
	{
		{ 0.262932373665163f, 0.153551471449999f, -0.291969634275151f }, { -0.708609143985588f, -0.514998048421491f, 0.468159964816915f }, { 0.0551260170047587f, -0.103445903417864f, 0.376255883682633f }, { 0.653683775467831f, -0.209613833397724f, 0.474524557390902f }, { -0.767495075439816f, -0.277635268454571f, -0.499126852976707f }, { 0.0517033820553658f, -0.450874096824908f, 0.259859999016614f }, { -0.328914949209403f, 0.315228929382438f, -0.149017858088919f }, { 0.0702011812650336f, -0.193692109698035f, -0.304651622963667f },
		{ 0.115919086058792f, -0.751681327447624f, -0.0578792834991346f }, { 0.105405347691047f, 0.596411986507577f, -0.33931739668656f }, { -0.106893530709245f, 0.280618421509181f, -0.832043100155617f }, { -0.0654181807636467f, -0.817494727882153f, 0.527423134166989f }, { -0.66607712436171f, 0.387833863130976f, -0.311127054266423f }, { 0.222366128263935f, 0.434069356849451f, 0.00109203594106155f }, { -0.582103888739791f, -0.403986953332572f, -0.165705027911859f }, { 0.147627538078114f, 0.288260167875865f, -0.883529956736502f },
		{ -0.402250371905059f, 0.832656383831385f, 0.186741768838311f }, { 0.473464736343465f, -0.679703118275789f, -0.40077691322837f }, { -0.035237830398541f, -0.419372284464907f, -0.477838593663681f }, { -0.430487584231229f, -0.290911667411263f, 0.505812452597545f }, { 0.530931074100062f, -0.650579753053343f, 0.515492249408879f }, { 0.220881415711242f, -0.469097215411346f, 0.157019606755508f }, { 0.27675389355964f, 0.901383931545492f, 0.231732886094137f }, { -0.014879042790529f, 0.811750856488725f, -0.434024472541077f },
		{ 0.538380603929312f, -0.21066468611799f, -0.724148505984583f }, { -0.121759133523113f, -0.793801224166494f, -0.132237392467051f }, { 0.117840222824295f, -0.355374228588378f, 0.124682929359946f }, { 0.688176141934959f, 0.521187417030148f, 0.345118407050836f }, { 0.407086542191789f, 0.732926996979246f, -0.209010702506625f }, { 0.32581242531042f, 0.558528412538481f, 0.71158552609818f }, { -0.555004950694707f, 0.516168523403744f, -0.240804448574935f }, { -0.904859502439036f, 0.0743969389263999f, 0.104715802991092f },
		{ 0.073325689986677f, -0.782036330994516f, -0.443786517587736f }, { -0.459555572527443f, 0.441887114861482f, -0.698441137965975f }, { -0.289668589713193f, 0.136769868484689f, -0.151654754992696f }, { 0.0237640444705514f, -0.269938670705644f, 0.607147708571096f }, { 0.67380601738027f, -0.309629481481464f, -0.460400343102835f }, { -0.397564983510291f, -0.673833834620159f, -0.0268946039774807f }, { 0.0462694151743761f, -0.45226005741164f, 0.49630646089289f }, { 0.866762371975284f, -0.295718510182752f, 0.0149819193522451f },
		{ 0.2029001303841f, -0.860056357816732f, -0.393452982216838f }, { -0.0998122338298171f, 0.294931944597187f, 0.178736158605963f }, { 0.875395522526907f, -0.0825672831515398f, -0.460278189186178f }, { 0.383915619327118f, 0.518552179491168f, 0.671760904200527f }, { -0.61311255399366f, 0.322849149919877f, 0.17618402803691f }, { -0.234437862015477f, -0.627320988866885f, -0.265500329226805f }, { 0.416683509524642f, -0.140340238885287f, -0.68350172163144f }, { -0.489865936729821f, 0.304547764633088f, -0.577657734402201f },
		{ 0.015759591666709f, -0.594032257039018f, 0.463159994056296f }, { 0.439192390921798f, -0.336126120843506f, -0.422737546477267f }, { 0.71744341454758f, -0.00698408270005091f, 0.499074258720097f }, { 0.252743757804593f, 0.0784696789857056f, -0.926006060991399f }, { 0.0956254270548202f, 0.884658796043882f, -0.0114316642871644f }, { -0.216903755102342f, -0.43309359670365f, 0.793361004002833f }, { 0.52089409573502f, -0.19360022054141f, 0.38119863467235f }, { 0.570874593801336f, -0.741499682901108f, 0.195220233022693f },
		{ 0.230116054141979f, -0.811711249775019f, -0.159575177040295f }, { -0.52123457383871f, 0.608624936295915f, 0.0449283489961014f }, { 0.127265509406933f, 0.112318538538559f, 0.922257260069714f }, { 0.0435935031911137f, 0.115754498653675f, 0.391429386205104f }, { 0.0102467351406248f, 0.431649787010987f, -0.398787878721233f }, { -0.458384483848666f, -0.427369330684921f, -0.587018487633901f }, { -0.483950934055113f, 0.417657401116388f, -0.491178601954959f }, { 0.236858447246911f, -0.458162993791689f, -0.263844368869653f },
		{ -0.340861098779621f, -0.295116464376117f, -0.000253402065530928f }, { -0.17073745544894f, -0.450108815269867f, -0.680400290523957f }, { 0.669276083671338f, 0.111032563569802f, -0.514052787961861f }, { 0.450325970818041f, -0.723645973102069f, -0.509385455376786f }, { 0.40546085170602f, 0.298810476349315f, 0.304299653922338f }, { -0.35105196810049f, 0.00378437413660104f, -0.164198941209194f }, { 0.15837401340184f, -0.58760716162567f, -0.213442574113378f }, { 0.504589866318021f, 0.770581155351702f, 0.371072038157382f },
		{ -0.569917417360092f, 0.559090216133928f, 0.160062597545231f }, { 0.160070848322477f, -0.0395876689862924f, -0.532067587816388f }, { -0.0162490333694416f, -0.166606441887101f, 0.59031696309757f }, { 0.207454135965524f, -0.0260188121959155f, -0.0599975464877465f }, { 0.383393993979441f, 0.663436168489971f, -0.157384854720779f }, { 0.350733297272835f, 0.316730570942483f, 0.577922336088516f }, { -0.570698620220757f, -0.175181454934868f, -0.480423100007302f }, { 0.245776347749264f, 0.427276333132852f, -0.688657145411795f },
		{ 0.00224144344693711f, 0.00486875393689057f, 0.188630013244312f }, { -0.22320226271512f, 0.923078828186733f, 0.296394027890566f }, { -0.449367472675937f, 0.269408537364126f, -0.390764128147193f }, { -0.394689368226122f, 0.142154313149621f, 0.800140356276413f }, { -0.230385706804416f, 0.485731274665201f, -0.492797919049728f }, { -0.380864075462633f, 0.467568868467785f, -0.603299465591556f }, { 0.548776278357963f, -0.537839005994549f, 0.397971844121229f }, { -0.275174053701755f, -0.391807088222938f, 0.480636386049214f },
		{ 0.284656397891213f, 0.0581184553813519f, -0.841053249656449f }, { -0.386828737091746f, -0.235379652741697f, 0.263850790355352f }, { 0.143987287842321f, 0.755274882908506f, 0.422080517050494f }, { 0.000470724533063294f, -0.0473107320549859f, 0.0724971409709871f }, { 0.103391561905551f, -0.917431070027245f, 0.119939586652184f }, { -0.0457566323054017f, 0.0442951353165546f, -0.535182076224448f }, { -0.641716861271846f, -0.3611219930046f, -0.459985999588059f }, { -0.317723907645648f, 0.473887486072258f, -0.0815424940022806f },
		{ -0.150956959580923f, -0.898069335729604f, -0.0749817012181173f }, { -0.0694370536183593f, -0.809740700114329f, -0.524988425169715f }, { 0.0183640251609041f, 0.00284625229352731f, 0.0961110706401243f }, { -0.620624836946168f, -0.562868042878287f, -0.205118401290757f }, { 0.408689589075526f, -0.501262203450612f, 0.277695531087804f }, { 0.186931149366143f, -0.663548375891839f, 0.355733357372202f }, { -0.141842957269254f, 0.120921681621546f, -0.671084668688337f }, { -0.264873428039199f, 0.283796022182013f, 0.264201694496239f },
		{ 0.845910171349198f, 0.115571332098421f, -0.0593372087567183f }, { 0.506886450146619f, 0.58255219714823f, 0.509438518167282f }, { 0.511438935024482f, 0.313488364222524f, -0.134014278985907f }, { 0.335472286345643f, 0.0563688323103442f, 0.371470647626975f }, { 0.762365131690096f, 0.504192783610985f, -0.235338237516637f }, { 0.620629080010914f, 0.164210058630659f, -0.506830471222315f }, { 0.915246129596587f, -0.399684515794182f, 0.0460348647894813f }, { -0.443640166123101f, -0.411333818521207f, -0.228855711069713f },
		{ -0.0891555675181099f, 0.424254955210822f, 0.705840028112787f }, { 0.374854327358691f, -0.901486549279051f, -0.177736019017455f }, { 0.907817968660537f, -0.0159931756505556f, -0.148322983300674f }, { 0.414043522473934f, 0.0396720299759967f, -0.154121976568144f }, { -0.215641489200622f, -0.863190025563005f, 0.282817477121766f }, { -0.493384676399966f, -0.486965227586759f, -0.277041556868121f }, { -0.145413267930942f, 0.367234756450644f, 0.255892208595349f }, { 0.208240177121022f, 0.0679624055226822f, -0.11065853298164f },
		{ -0.783340968157716f, 0.494544372295232f, 0.0986476741588405f }, { -0.465821052204292f, -0.254657063635933f, -0.203297244054974f }, { 0.182339141215468f, -0.599744300940732f, 0.149427656165992f }, { 0.255210939940937f, -0.637324227353845f, 0.356059851123357f }, { 0.069708224081209f, 0.153461716043562f, 0.890917610812324f }, { -0.672197456743714f, 0.0338542979125953f, 0.516046304990767f }, { 0.0796552321449462f, 0.423954290457488f, -0.273956291079693f }, { 0.237432509436643f, -0.790497730916185f, -0.124872981867872f },
	};

	protected CellularDistanceFunctionType cellularDistanceFunction;
	protected CellularReturnType cellularReturnType;

	/// <summary>
	/// Set the method used for computing cellular distances.
	/// </summary>
	/// <param name="type">Cellular distance function type.</param>
	public void SetCellularDistanceFunction( CellularDistanceFunctionType type )
	{
		cellularDistanceFunction = type;
	}

	/// <summary>
	/// Set the type returned by cellular noise.
	/// </summary>
	/// <param name="type">Cellular noise return type.</param>
	public void SetCellularReturnType( CellularReturnType type )
	{
		cellularReturnType = type;
	}

	/// <summary>
	/// NoiseBasic Constructor.
	/// </summary>
	public NoiseCellular( )
	{
		noiseType = NoiseType.Cellular;
	}

	float GetCellular( float x, float y, float z )
	{
		x*= frequency;
		y*= frequency;
		z*= frequency;

		switch( cellularReturnType )
		{
			case CellularReturnType.DistanceToEdge:
			case CellularReturnType.DistanceToEdgeXValue:
			case CellularReturnType.DistanceToEdgeSq:
			case CellularReturnType.DistanceToEdgeSqXValue:
				return _CellularToEdge( x, y, z );

			default:
				return _Cellular( x, y, z );
		}
	}

	float _CellularToEdge( float x, float y, float z )
	{
		int xr = FastRound( x );
		int yr = FastRound( y );
		int zr = FastRound( z );

		float distance = float.MaxValue;
		float distance2 = float.MaxValue;
		float newDistance;
		float[] vec = new float [3];
		int lutPos;
		int xc = 0, yc = 0, zc = 0;

		switch( cellularDistanceFunction )
		{
			case CellularDistanceFunctionType.Euclidean:
				for( int xi = xr - 1; xi <= xr + 1; ++xi )
				{
					for( int yi = yr - 1; yi <= yr + 1; ++yi )
					{
						for( int zi = zr - 1; zi <= zr + 1; ++zi )
						{
							lutPos = GetLUTIndex( xi, yi, zi );

							vec[0] = xi - x + LUT_Cellular3D[lutPos, 0];
							vec[1] = yi - y + LUT_Cellular3D[lutPos, 1];
							vec[2] = zi - z + LUT_Cellular3D[lutPos, 2];

							newDistance = vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2];
							if( newDistance < distance )
							{
								distance2 = distance;

								distance = newDistance;
								xc = xi;
								yc = yi;
								zc = zi;
							}
							else if( newDistance < distance2 )
							{
								distance2 = newDistance;
							}
						}
					}
				}
			break;

			case CellularDistanceFunctionType.Manhattan:
				for( int xi = xr - 1; xi <= xr + 1; ++xi )
				{
					for( int yi = yr - 1; yi <= yr + 1; ++yi )
					{
						for( int zi = zr - 1; zi <= zr + 1; ++zi )
						{
							lutPos = GetLUTIndex( xi, yi, zi );

							vec[0] = xi - x + LUT_Cellular3D[lutPos, 0];
							vec[1] = yi - y + LUT_Cellular3D[lutPos, 1];
							vec[2] = zi - z + LUT_Cellular3D[lutPos, 2];

							newDistance = FastAbs( vec[0] ) + FastAbs( vec[1] ) + FastAbs( vec[2] );
							if( newDistance < distance )
							{
								distance2 = distance;

								distance = newDistance;
								xc = xi;
								yc = yi;
								zc = zi;
							}
							else if( newDistance < distance2 )
							{
								distance2 = newDistance;
							}
						}
					}
				}
			break;

			case CellularDistanceFunctionType.Natural:
				for( int xi = xr - 1; xi <= xr + 1; ++xi )
				{
					for( int yi = yr - 1; yi <= yr + 1; ++yi )
					{
						for( int zi = zr - 1; zi <= zr + 1; ++zi )
						{
							lutPos = GetLUTIndex( xi, yi, zi );

							vec[0] = xi - x + LUT_Cellular3D[lutPos, 0];
							vec[1] = yi - y + LUT_Cellular3D[lutPos, 1];
							vec[2] = zi - z + LUT_Cellular3D[lutPos, 2];

							newDistance = ( FastAbs( vec[0] ) + FastAbs( vec[1] ) + FastAbs( vec[2] ) )*( vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2] );
							if( newDistance < distance )
							{
								distance2 = distance;

								distance = newDistance;
								xc = xi;
								yc = yi;
								zc = zi;
							}
							else if( newDistance < distance2 )
							{
								distance2 = newDistance;
							}
						}
					}
				}
			break;

			default:
			break;
		}

		switch( cellularReturnType )
		{
			case CellularReturnType.DistanceToEdge:
				return( Mathf.Sqrt( distance2 ) - Mathf.Sqrt( distance ) );
			
			case CellularReturnType.DistanceToEdgeXValue:
				return( ( Mathf.Sqrt( distance2 ) - Mathf.Sqrt( distance ) )*NoiseBasic.LUT_Value[GetLUTIndex( xc, yc, zc )] );

			case CellularReturnType.DistanceToEdgeSq:
				return( distance2 - distance );

			case CellularReturnType.DistanceToEdgeSqXValue:
				return( ( distance2 - distance )*NoiseBasic.LUT_Value[GetLUTIndex( xc, yc, zc )] );

			default:
				return 0.0f;
		}
	}

	float GetCellularHQ( float x, float y, float z )
	{
		x*= frequency;
		y*= frequency;
		z*= frequency;

		switch( cellularReturnType )
		{
			case CellularReturnType.DistanceToEdge:
			case CellularReturnType.DistanceToEdgeXValue:
			case CellularReturnType.DistanceToEdgeSq:
			case CellularReturnType.DistanceToEdgeSqXValue:
				return( _CellularToEdgeHQ( x, y, z ) );

			default:
				return( _CellularHQ( x, y, z ) );
		}
	}

	float _CellularHQ( float x, float y, float z )
	{
		int xr = FastRound( x );
		int yr = FastRound( y );
		int zr = FastRound( z );

		float distance = float.MaxValue;
		float newDistance = 0.0f;
		float[] vec = new float [3];
		int lutPos = 0;
		int xc = 0;
		int yc = 0;
		int zc = 0;

		switch( cellularDistanceFunction )
		{
			case CellularDistanceFunctionType.Euclidean:
				for( int xi = xr - 2; xi <= xr + 2; ++xi )
				{
					for( int yi = yr - 2; yi <= yr + 2; ++yi )
					{
						for( int zi = zr - 2; zi <= zr + 2; ++zi )
						{
							lutPos = GetLUTIndex( xi, yi, zi );

							vec[0] = xi - x + LUT_Cellular3D_HQ[lutPos, 0];
							vec[1] = yi - y + LUT_Cellular3D_HQ[lutPos, 1];
							vec[2] = zi - z + LUT_Cellular3D_HQ[lutPos, 2];

							newDistance = vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2];
							if( newDistance < distance )
							{
								distance = newDistance;
								xc = xi;
								yc = yi;
								zc = zi;
							}
						}
					}
				}
			break;

			case CellularDistanceFunctionType.Manhattan:
				for( int xi = xr - 2; xi <= xr + 2; ++xi )
				{
					for( int yi = yr - 2; yi <= yr + 2; ++yi )
					{
						for( int zi = zr - 2; zi <= zr + 2; ++zi )
						{
							lutPos = GetLUTIndex( xi, yi, zi );

							vec[0] = xi - x + LUT_Cellular3D_HQ[lutPos, 0];
							vec[1] = yi - y + LUT_Cellular3D_HQ[lutPos, 1];
							vec[2] = zi - z + LUT_Cellular3D_HQ[lutPos, 2];

							newDistance = FastAbs( vec[0] ) + FastAbs( vec[1] ) + FastAbs( vec[2] );
							if( newDistance < distance )
							{
								distance = newDistance;
								xc = xi;
								yc = yi;
								zc = zi;
							}
						}
					}
				}
			break;

			case CellularDistanceFunctionType.Natural:
				for( int xi = xr - 2; xi <= xr + 2; xi++ )
				{
					for( int yi = yr - 2; yi <= yr + 2; yi++ )
					{
						for( int zi = zr - 2; zi <= zr + 2; zi++ )
						{
							lutPos = GetLUTIndex( xi, yi, zi );

							vec[0] = xi - x + LUT_Cellular3D_HQ[lutPos, 0];
							vec[1] = yi - y + LUT_Cellular3D_HQ[lutPos, 1];
							vec[2] = zi - z + LUT_Cellular3D_HQ[lutPos, 2];

							newDistance = ( FastAbs( vec[0] ) + FastAbs( vec[1] ) + FastAbs( vec[2] ) )*( vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2] );
							if( newDistance < distance )
							{
								distance = newDistance;
								xc = xi;
								yc = yi;
								zc = zi;
							}
						}
					}
				}
			break;

			default:
			break;
		}

		switch( cellularReturnType )
		{
			case CellularReturnType.CellValue:
				return NoiseBasic.LUT_Value[GetLUTIndex( xc, yc, zc )];

			case CellularReturnType.NoiseLookup:
				if( !cellularNoiseLookup )
					return 0;

				lutPos = GetLUTIndex( xc, yc, zc );
				return( cellularNoiseLookup->GetNoise( xc + LUT_Cellular3D_HQ[lutPos, 0], yc + LUT_Cellular3D_HQ[lutPos, 1], zc + LUT_Cellular3D_HQ[lutPos, 2] ) );

			case CellularReturnType.DistanceToCenter:
				return( Mathf.Sqrt( distance ) );
			
			case CellularReturnType.DistanceToCenterXValue:
				return( ( 1.0f - Mathf.Sqrt( distance ) )*NoiseBasic.LUT_Value[GetLUTIndex( xc, yc, zc )] );

			case CellularReturnType.DistanceToCenterSq:
				return distance;
			
			case CellularReturnType.DistanceToCenterSqXValue:
				return( ( 1.0f - distance )*NoiseBasic.LUT_Value[GetLUTIndex( xc, yc, zc )] );

			default:
				return 0.0f;
		}
	}

	float _CellularToEdgeHQ( float x, float y, float z )
	{
		int xr = FastRound( x );
		int yr = FastRound( y );
		int zr = FastRound( z );

		float distance = float.MaxValue;
		float distance2 = float.MaxValue;
		float newDistance;
		float[] vec = new float [3];
		int lutPos = 0;
		int xc = 0;
		int yc = 0;
		int zc = 0;

		switch( cellularDistanceFunction )
		{
			case CellularDistanceFunctionType.Euclidean:
				for( int xi = xr - 2; xi <= xr + 2; ++xi )
				{
					for( int yi = yr - 2; yi <= yr + 2; ++yi )
					{
						for( int zi = zr - 2; zi <= zr + 2; ++zi )
						{
							lutPos = GetLUTIndex( xi, yi, zi );

							vec[0] = xi - x + LUT_Cellular3D_HQ[lutPos, 0];
							vec[1] = yi - y + LUT_Cellular3D_HQ[lutPos, 1];
							vec[2] = zi - z + LUT_Cellular3D_HQ[lutPos, 2];

							newDistance = vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2];

							if( newDistance < distance )
							{
								distance2 = distance;

								distance = newDistance;
								xc = xi;
								yc = yi;
								zc = zi;
							}
							else if( newDistance < distance2 )
							{
								distance2 = newDistance;
							}
						}
					}
				}
			break;

			case CellularDistanceFunctionType.Manhattan:
				for( int xi = xr - 2; xi <= xr + 2; ++xi )
				{
					for( int yi = yr - 2; yi <= yr + 2; ++yi )
					{
						for( int zi = zr - 2; zi <= zr + 2; ++zi )
						{
							lutPos = GetLUTIndex( xi, yi, zi );

							vec[0] = xi - x + LUT_Cellular3D_HQ[lutPos, 0];
							vec[1] = yi - y + LUT_Cellular3D_HQ[lutPos, 1];
							vec[2] = zi - z + LUT_Cellular3D_HQ[lutPos, 2];

							newDistance = FastAbs( vec[0] ) + FastAbs( vec[1] ) + FastAbs( vec[2] );
							if( newDistance < distance )
							{
								distance2 = distance;

								distance = newDistance;
								xc = xi;
								yc = yi;
								zc = zi;
							}
							else if( newDistance < distance2 )
							{
								distance2 = newDistance;
							}
						}
					}
				}
			break;

			case CellularDistanceFunctionType.Natural:
				for( int xi = xr - 2; xi <= xr + 2; ++xi )
				{
					for( int yi = yr - 2; yi <= yr + 2; ++yi )
					{
						for( int zi = zr - 2; zi <= zr + 2; ++zi )
						{
							lutPos = GetLUTIndex( xi, yi, zi );

							vec[0] = xi - x + LUT_Cellular3D_HQ[lutPos, 0];
							vec[1] = yi - y + LUT_Cellular3D_HQ[lutPos, 1];
							vec[2] = zi - z + LUT_Cellular3D_HQ[lutPos, 2];

							newDistance = ( FastAbs( vec[0] ) + FastAbs( vec[1] ) + FastAbs( vec[2] ) )*( vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2] );
							if( newDistance < distance )
							{
								distance2 = distance;

								distance = newDistance;
								xc = xi;
								yc = yi;
								zc = zi;
							}
							else if( newDistance < distance2 )
							{
								distance2 = newDistance;
							}
						}
					}
				}
			break;

			default:
			break;
		}

		switch( cellularReturnType )
		{
			case CellularReturnType.DistanceToEdge:
				return( Mathf.Sqrt( distance2 ) - Mathf.Sqrt( distance ) );

			case CellularReturnType.DistanceToEdgeXValue:
				return( ( Mathf.Sqrt( distance2 ) - Mathf.Sqrt( distance ) )*NoiseBasic.LUT_Value[GetLUTIndex( xc, yc, zc )] );

			case CellularReturnType.DistanceToEdgeSq:
				return( distance2 - distance );
			
			case CellularReturnType.DistanceToEdgeSqXValue:
				return( ( distance2 - distance )*NoiseBasic.LUT_Value[GetLUTIndex( xc, yc, zc )] );

			default:
				return 0.0f;
		}
	}

	float GetCellular( float x, float y )
	{
		x*= frequency;
		y*= frequency;

		switch( cellularReturnType )
		{
			case CellularReturnType.DistanceToEdge:
			case CellularReturnType.DistanceToEdgeXValue:
			case CellularReturnType.DistanceToEdgeSq:
			case CellularReturnType.DistanceToEdgeSqXValue:
				return _CellularToEdge( x, y );
	
			default:
				return _Cellular( x, y );
		}
	}

	float _Cellular( float x, float y )
	{
		int xr = FastRound( x );
		int yr = FastRound( y );

		float distance = float.MaxValue;
		float newDistance = 0.0f;
		float[] vec = new float [2];
		int lutPos = 0;
		int xc = 0;
		int yc = 0;

		switch( cellularDistanceFunction )
		{
			default:
			case CellularDistanceFunctionType.Euclidean:
				for( int xi = xr - 1; xi <= xr + 1; ++xi )
				{
					for( int yi = yr - 1; yi <= yr + 1; ++yi )
					{
						lutPos = GetLUTIndex( xi, yi );

						vec[0] = xi - x + LUT_Cellular2D_HQ[lutPos, 0];
						vec[1] = yi - y + LUT_Cellular2D_HQ[lutPos, 1];

						newDistance = vec[0]*vec[0] + vec[1]*vec[1];
						if( newDistance < distance )
						{
							distance = newDistance;
							xc = xi;
							yc = yi;
						}
					}
				}
			break;

			case CellularDistanceFunctionType.Manhattan:
				for( int xi = xr - 1; xi <= xr + 1; ++xi )
				{
					for( int yi = yr - 1; yi <= yr + 1; ++yi )
					{
						lutPos = GetLUTIndex( xi, yi );

						vec[0] = xi - x + LUT_Cellular2D[lutPos, 0];
						vec[1] = yi - y + LUT_Cellular2D[lutPos, 1];

						newDistance = ( FastAbs( vec[0] ) + FastAbs( vec[1] ) );
						if( newDistance < distance )
						{
							distance = newDistance;
							xc = xi;
							yc = yi;
						}
					}
				}
			break;

			case CellularDistanceFunctionType.Natural:
				for( int xi = xr - 1; xi <= xr + 1; ++xi )
				{
					for( int yi = yr - 1; yi <= yr + 1; ++yi )
					{
						lutPos = GetLUTIndex( xi, yi );

						vec[0] = xi - x + LUT_Cellular2D[lutPos, 0];
						vec[1] = yi - y + LUT_Cellular2D[lutPos, 1];

						newDistance = ( FastAbs( vec[0] ) + FastAbs( vec[1] ) )*( vec[0]*vec[0] + vec[1]*vec[1] );
						if( newDistance < distance )
						{
							distance = newDistance;
							xc = xi;
							yc = yi;
						}
					}
				}
			break;
		}

		switch( cellularReturnType )
		{
			case CellularReturnType.CellValue:
				return NoiseBasic.LUT_Value[GetLUTIndex( xc, yc )];

			case CellularReturnType.NoiseLookup:
				if( !cellularNoiseLookup )
					return 0;

				lutPos = GetLUTIndex( xc, yc );
				return( cellularNoiseLookup->GetNoise( xc + LUT_Cellular2D[lutPos, 0], yc + LUT_Cellular2D[lutPos, 1] ) );

			case CellularReturnType.DistanceToCenter:
				return( Mathf.Sqrt( distance ) );
			
			case CellularReturnType.DistanceToCenterXValue:
				return( ( 1.0f - Mathf.Sqrt( distance ) )*NoiseBasic.LUT_Value[GetLUTIndex( xc, yc )] );

			case CellularReturnType.DistanceToCenterSq:
				return distance;
			
			case CellularReturnType.DistanceToCenterSqXValue:
				return( ( 1.0f - distance )*NoiseBasic.LUT_Value[GetLUTIndex( xc, yc )] );

			default:
				return 0.0f;
		}
	}

	/// <summary>
	/// Get a 3D noise value.
	/// </summary>
	/// <param name="x">x</param>
	/// <param name="y">y</param>
	/// <param name="z">z</param>
	/// <returns>Result of 3D noise.</returns>
	private float GetValue( float x, float y, float z )
	{
		int xr = FastRound( x );
		int yr = FastRound( y );
		int zr = FastRound( z );

		float distance = float.MaxValue;
		float newDistance = 0.0f;
		float[] vec = new float [3];
		int lutPos = 0;
		int xc = 0;
		int yc = 0;
		int zc = 0;

		switch( cellularDistanceFunction )
		{
			case CellularDistanceFunctionType.Euclidean:
				for( int xi = xr - 1; xi <= xr + 1; ++xi )
				{
					for( int yi = yr - 1; yi <= yr + 1; ++yi )
					{
						for( int zi = zr - 1; zi <= zr + 1; ++zi )
						{
							lutPos = GetLUTIndex( xi, yi, zi );

							vec[0] = xi - x + LUT_Cellular3D[lutPos, 0];
							vec[1] = yi - y + LUT_Cellular3D[lutPos, 1];
							vec[2] = zi - z + LUT_Cellular3D[lutPos, 2];

							newDistance = vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2];
							if( newDistance < distance )
							{
								distance = newDistance;
								xc = xi;
								yc = yi;
								zc = zi;
							}
						}
					}
				}
			break;

			case CellularDistanceFunctionType.Manhattan:
				for( int xi = xr - 1; xi <= xr + 1; ++xi )
				{
					for( int yi = yr - 1; yi <= yr + 1; ++yi )
					{
						for( int zi = zr - 1; zi <= zr + 1; ++zi )
						{
							lutPos = GetLUTIndex( xi, yi, zi );

							vec[0] = xi - x + LUT_Cellular3D[lutPos, 0];
							vec[1] = yi - y + LUT_Cellular3D[lutPos, 1];
							vec[2] = zi - z + LUT_Cellular3D[lutPos, 2];

							newDistance = FastAbs( vec[0] ) + FastAbs( vec[1] ) + FastAbs( vec[2] );
							if( newDistance < distance )
							{
								distance = newDistance;
								xc = xi;
								yc = yi;
								zc = zi;
							}
						}
					}
				}
			break;

			case CellularDistanceFunctionType.Natural:
				for( int xi = xr - 1; xi <= xr + 1; ++xi )
				{
					for( int yi = yr - 1; yi <= yr + 1; ++yi )
					{
						for( int zi = zr - 1; zi <= zr + 1; ++zi )
						{
							lutPos = GetLUTIndex( xi, yi, zi );

							vec[0] = xi - x + LUT_Cellular3D[lutPos, 0];
							vec[1] = yi - y + LUT_Cellular3D[lutPos, 1];
							vec[2] = zi - z + LUT_Cellular3D[lutPos, 2];

							newDistance = ( FastAbs( vec[0] ) + FastAbs( vec[1] ) + FastAbs( vec[2] ) )*( vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2] );
							if( newDistance < distance )
							{
								distance = newDistance;
								xc = xi;
								yc = yi;
								zc = zi;
							}
						}
					}
				}
			break;

			default:
			break;
		}

		switch( cellularReturnType )
		{
			case CellularReturnType.CellValue:
				return( NoiseBasic.LUT_Value[GetLUTIndex( xc, yc, zc )] );

			case CellularReturnType.NoiseLookup:
				if( !cellularNoiseLookup )
					return 0;

				lutPos = GetLUTIndex( xc, yc, zc );
				return( cellularNoiseLookup->GetNoise( xc + LUT_Cellular3D[lutPos, 0], yc + LUT_Cellular3D[lutPos, 1], zc + LUT_Cellular3D[lutPos, 2] ) );

			case CellularReturnType.DistanceToCenter:
				return( Mathf.Sqrt( distance ) );

			case CellularReturnType.DistanceToCenterXValue:
				return( ( 1.0f - Mathf.Sqrt( distance ) )*NoiseBasic.LUT_Value[GetLUTIndex( xc, yc, zc )] );

			case CellularReturnType.DistanceToCenterSq:
				return distance;
			
			case CellularReturnType.DistanceToCenterSqXValue:
				return( ( 1.0f - distance )*NoiseBasic.LUT_Value[GetLUTIndex( xc, yc, zc )] );

			default:
				return 0.0f;
		}

		return 0.0f;
	}

	float _CellularToEdge( float x, float y )
	{
		int xr = FastRound( x );
		int yr = FastRound( y );

		float distance = float.MaxValue;
		float distance2 = float.MaxValue;
		float newDistance = 0.0f;
		float vec[2];
		int lutPos;
		int xc = 0, yc = 0;

		switch( m_cellularDistanceFunction )
		{
			default:
			case FastNoise::Euclidean:
			for( int xi = xr - 1; xi <= xr + 1; xi++ )
			{
				for( int yi = yr - 1; yi <= yr + 1; yi++ )
				{
					lutPos = CoordLUTIndex( m_seed, xi, yi );

					vec[0] = xi - x + CELLULAR2D_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR2D_LUT[lutPos][1];

					newDistance = vec[0] * vec[0] + vec[1] * vec[1];

					if( newDistance < distance )
					{
						distance2 = distance;

						distance = newDistance;
						xc = xi;
						yc = yi;
					}
					else if( newDistance < distance2 )
					{
						distance2 = newDistance;
					}
				}
			}
			break;
			case FastNoise::Manhattan:
			for( int xi = xr - 1; xi <= xr + 1; xi++ )
			{
				for( int yi = yr - 1; yi <= yr + 1; yi++ )
				{
					lutPos = CoordLUTIndex( m_seed, xi, yi );

					vec[0] = xi - x + CELLULAR2D_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR2D_LUT[lutPos][1];

					newDistance = FastAbs( vec[0] ) + FastAbs( vec[1] );

					if( newDistance < distance )
					{
						distance2 = distance;

						distance = newDistance;
						xc = xi;
						yc = yi;
					}
					else if( newDistance < distance2 )
					{
						distance2 = newDistance;
					}
				}
			}
			break;
			case FastNoise::Natural:
			for( int xi = xr - 1; xi <= xr + 1; xi++ )
			{
				for( int yi = yr - 1; yi <= yr + 1; yi++ )
				{
					lutPos = CoordLUTIndex( m_seed, xi, yi );

					vec[0] = xi - x + CELLULAR2D_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR2D_LUT[lutPos][1];

					newDistance = ( FastAbs( vec[0] ) + FastAbs( vec[1] ) ) * ( vec[0] * vec[0] + vec[1] * vec[1] );

					if( newDistance < distance )
					{
						distance2 = distance;

						distance = newDistance;
						xc = xi;
						yc = yi;
					}
					else if( newDistance < distance2 )
					{
						distance2 = newDistance;
					}
				}
			}
			break;
		}

		switch( m_cellularReturnType )
		{
			case FastNoise::Distance2Edge:
			return sqrtf( distance2 ) - sqrtf( distance );
			case FastNoise::Distance2EdgeXValue:
			return ( sqrtf( distance2 ) - sqrtf( distance ) ) * VAL_LUT[CoordLUTIndex( m_seed, xc, yc )];

			case FastNoise::Distance2EdgeSq:
			return distance2 - distance;
			case FastNoise::Distance2EdgeSqXValue:
			return ( distance2 - distance ) * VAL_LUT[CoordLUTIndex( m_seed, xc, yc )];
			default:
			return 0.0f;
		}
	}

	float FastNoise::GetCellularHQ( float x, float y )
	{
		x *= m_frequency;
		y *= m_frequency;

		switch( m_cellularReturnType )
		{
			case Distance2Edge:
			case Distance2EdgeXValue:
			case Distance2EdgeSq:
			case Distance2EdgeSqXValue:
			return _Cellular2EdgeHQ( x, y );
			default:
			return _CellularHQ( x, y );
		}
	}

	float FastNoise::_CellularHQ( float x, float y )
	{
		int xr = FastRound( x );
		int yr = FastRound( y );

		float distance = 999999.f;
		float newDistance;
		float vec[2];
		int lutPos;
		int xc, yc;

		switch( m_cellularDistanceFunction )
		{
			default:
			case Euclidean:
			for( int xi = xr - 2; xi <= xr + 2; xi++ )
			{
				for( int yi = yr - 2; yi <= yr + 2; yi++ )
				{
					lutPos = CoordLUTIndex( m_seed, xi, yi );

					vec[0] = xi - x + CELLULAR2D_HQ_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR2D_HQ_LUT[lutPos][1];

					newDistance = vec[0] * vec[0] + vec[1] * vec[1];

					if( newDistance < distance )
					{
						distance = newDistance;
						xc = xi;
						yc = yi;
					}
				}
			}
			break;
			case Manhattan:
			for( int xi = xr - 2; xi <= xr + 2; xi++ )
			{
				for( int yi = yr - 2; yi <= yr + 2; yi++ )
				{
					lutPos = CoordLUTIndex( m_seed, xi, yi );

					vec[0] = xi - x + CELLULAR2D_HQ_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR2D_HQ_LUT[lutPos][1];

					newDistance = FastAbs( vec[0] ) + FastAbs( vec[1] );

					if( newDistance < distance )
					{
						distance = newDistance;
						xc = xi;
						yc = yi;
					}
				}
			}
			break;
			case Natural:
			for( int xi = xr - 2; xi <= xr + 2; xi++ )
			{
				for( int yi = yr - 2; yi <= yr + 2; yi++ )
				{
					lutPos = CoordLUTIndex( m_seed, xi, yi );

					vec[0] = xi - x + CELLULAR2D_HQ_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR2D_HQ_LUT[lutPos][1];

					newDistance = ( FastAbs( vec[0] ) + FastAbs( vec[1] ) ) * ( vec[0] * vec[0] + vec[1] * vec[1] );

					if( newDistance < distance )
					{
						distance = newDistance;
						xc = xi;
						yc = yi;
					}
				}
			}
			break;
		}

		switch( m_cellularReturnType )
		{
			case FastNoise::CellValue:
			return VAL_LUT[CoordLUTIndex( m_seed, xc, yc )];

			case FastNoise::NoiseLookup:
			if( !m_cellularNoiseLookup )
				return 0;

			lutPos = CoordLUTIndex( m_seed, xc, yc );
			return m_cellularNoiseLookup->GetNoise( xc + CELLULAR2D_HQ_LUT[lutPos][0], yc + CELLULAR2D_HQ_LUT[lutPos][1] );

			case FastNoise::Distance2Center:
			return sqrtf( distance );
			case FastNoise::Distance2CenterXValue:
			return ( 1.0f - sqrtf( distance ) ) * VAL_LUT[CoordLUTIndex( m_seed, xc, yc )];

			case FastNoise::Distance2CenterSq:
			return distance;
			case FastNoise::Distance2CenterSqXValue:
			return ( 1.0f - distance ) * VAL_LUT[CoordLUTIndex( m_seed, xc, yc )];
			default:
			return 0.0f;
		}
	}

	float FastNoise::_Cellular2EdgeHQ( float x, float y )
	{
		int xr = FastRound( x );
		int yr = FastRound( y );

		float distance = 999999.f;
		float distance2 = 999999.f;
		float newDistance;
		float vec[2];
		int lutPos;
		int xc = 0, yc = 0;

		switch( m_cellularDistanceFunction )
		{
			default:
			case Euclidean:
			for( int xi = xr - 2; xi <= xr + 2; xi++ )
			{
				for( int yi = yr - 2; yi <= yr + 2; yi++ )
				{
					lutPos = CoordLUTIndex( m_seed, xi, yi );

					vec[0] = xi - x + CELLULAR2D_HQ_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR2D_HQ_LUT[lutPos][1];

					newDistance = vec[0] * vec[0] + vec[1] * vec[1];

					if( newDistance < distance )
					{
						distance2 = distance;

						distance = newDistance;
						xc = xi;
						yc = yi;
					}
					else if( newDistance < distance2 )
					{
						distance2 = newDistance;
					}
				}
			}
			break;
			case Manhattan:
			for( int xi = xr - 2; xi <= xr + 2; xi++ )
			{
				for( int yi = yr - 2; yi <= yr + 2; yi++ )
				{
					lutPos = CoordLUTIndex( m_seed, xi, yi );

					vec[0] = xi - x + CELLULAR2D_HQ_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR2D_HQ_LUT[lutPos][1];

					newDistance = FastAbs( vec[0] ) + FastAbs( vec[1] );

					if( newDistance < distance )
					{
						distance2 = distance;

						distance = newDistance;
						xc = xi;
						yc = yi;
					}
					else if( newDistance < distance2 )
					{
						distance2 = newDistance;
					}
				}
			}
			break;
			case Natural:
			for( int xi = xr - 2; xi <= xr + 2; xi++ )
			{
				for( int yi = yr - 2; yi <= yr + 2; yi++ )
				{
					lutPos = CoordLUTIndex( m_seed, xi, yi );

					vec[0] = xi - x + CELLULAR2D_HQ_LUT[lutPos][0];
					vec[1] = yi - y + CELLULAR2D_HQ_LUT[lutPos][1];

					newDistance = ( FastAbs( vec[0] ) + FastAbs( vec[1] ) ) * ( vec[0] * vec[0] + vec[1] * vec[1] );

					if( newDistance < distance )
					{
						distance2 = distance;

						distance = newDistance;
						xc = xi;
						yc = yi;
					}
					else if( newDistance < distance2 )
					{
						distance2 = newDistance;
					}
				}
			}
			break;
		}

		switch( m_cellularReturnType )
		{
			case FastNoise::Distance2Edge:
			return sqrtf( distance2 ) - sqrtf( distance );
			case FastNoise::Distance2EdgeXValue:
			return ( sqrtf( distance2 ) - sqrtf( distance ) ) * VAL_LUT[CoordLUTIndex( m_seed, xc, yc )];

			case FastNoise::Distance2EdgeSq:
			return distance2 - distance;
			case FastNoise::Distance2EdgeSqXValue:
			return ( distance2 - distance ) * VAL_LUT[CoordLUTIndex( m_seed, xc, yc )];
			default:
			return 0.0f;
		}
	}
}
